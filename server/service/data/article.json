{
  "RECORDS": [
    {
      "article_id": "222",
      "article_title": "box-shadow",
      "article_content": "<div><div>参数说明</div><div>```</div><div>box-shadow: 2px 2px 4px 1px red insert;</div><div>```</div><div><br></div><div>参数从左到右依次是，水平阴影位置(必须)、垂直阴影位置（必须）、模糊距离（可选）、阴影扩展半径（可选） 阴影颜色（可选）、阴影向内（可选，不选向外）</div><div><br></div><div>1、**水平阴影位置、垂直阴影位置**：水平/垂直移动阴影的距离</div><div>box-shadow: 200px 10px 0px 0px black; （这里的矩形宽度为200px）</div></div><div><span class=\"img-wrapper\"></span><span class=\"img-wrapper\"><img src=\"http://119.45.55.131:3000/upload/oBksxEiJJYs60aTWtk3adHlH.png\"><span>![在这里插入图片描述](http://119.45.55.131:3000/upload/oBksxEiJJYs60aTWtk3adHlH.png)</span></span><br></div><div><div>2、**阴影扩展半径**：在原矩形阴影的基础上，向外延伸阴影扩展半径区域</div><div><br></div><div>box-shadow: 210px 0px 0px **0px** black; &nbsp;</div></div><div><span class=\"img-wrapper\"><img src=\"http://119.45.55.131:3000/upload/I_QvzC8PXJqPRjYEOHZlQCgu.png\"><span>![在这里插入图片描述](http://119.45.55.131:3000/upload/I_QvzC8PXJqPRjYEOHZlQCgu.png)</span></span><br></div><div>box-shadow: 210px 0px 0px **10px** black; （增加的阴影扩展半径10px刚好填满中间的距离10px）<br></div><div><span class=\"img-wrapper\"><img src=\"http://119.45.55.131:3000/upload/uP18Zjt9rdcLFnzh_kxFxlt0.png\"><span>![在这里插入图片描述](http://119.45.55.131:3000/upload/uP18Zjt9rdcLFnzh_kxFxlt0.png)</span></span><br></div><div><div>3、**模糊距离：阴影大小（加上模糊的） = 原矩形大小 +&nbsp; &nbsp;阴影扩展半径区域 + 模糊距离区域/2**</div><div>box-shadow: 230px 0px **0px** 30px black;&nbsp;</div></div><div><span class=\"img-wrapper\"><img src=\"http://119.45.55.131:3000/upload/9v2G9kZRKzXv_M6ybMjKSw3z.png\"><span>![在这里插入图片描述](http://119.45.55.131:3000/upload/9v2G9kZRKzXv_M6ybMjKSw3z.png)</span></span><br></div><div><div>box-shadow: 230px 0px **10px** 30px black;&nbsp;</div><div>增加了模糊距离10px，模糊部分超出原矩形右边框。模糊部分也包含原矩形右边框的右侧。</div></div><div><span class=\"img-wrapper\"><img src=\"http://119.45.55.131:3000/upload/lz4HkfppMWun7bLxeDP5VZKS.png\"><span>![在这里插入图片描述](http://119.45.55.131:3000/upload/lz4HkfppMWun7bLxeDP5VZKS.png)</span></span><br></div><div><div>box-shadow: **235px** 0px 10px 30px black;</div><div>矩形间的距离，增大5px，就刚好填满中间的距离。中间距离35px = 阴影扩展半径30px + 模糊距离/2 （5px）</div></div><div><span class=\"img-wrapper\"><img src=\"http://119.45.55.131:3000/upload/gl5kbaAvh9ebGc-wc__xfE_b.png\"><span>![在这里插入图片描述](http://119.45.55.131:3000/upload/gl5kbaAvh9ebGc-wc__xfE_b.png)</span></span><br></div><div><div>**两者的关系：**</div><div>通过取色器发现阴影部分中间的颜色都是一样的，只有边缘有颜色由深到浅的变化（模糊距离）。结合上面得出，**模糊距离，是以最外层的阴影边框为中间线（最外层为，阴影扩展半径区域+原矩形阴影部分）向两边延伸各一半的长度。该中间线两边的模糊变化由内到外，颜色由深变浅，其中变化范围长度为模糊距离。**</div></div><div><br></div><div><br></div><div><br></div>",
      "article_time": "2024-7-7 12:23:08",
      "categories_id": "11",
      "tags": "box-shadow"
    },
    {
      "article_id": "223",
      "article_title": "Node.js简单使用cookie，帮助理解实现原理和交互过程",
      "article_content": "<div>HTTP是一个无状态的协议，而现实中的业务是需要一定状态的，否则无法区分用户的身份。通过使用Cookie能帮助我们标识不同身份的用户。可用于记录服务器于客户端之间的状态，最早的用处是用于判断用户是否第一次登陆，如下面部分的代码。</div><div><br></div><div>Cookie的处理分为：</div><div><br></div><div> - 服务器向客户端发送Cookie</div><div>&nbsp;- 浏览器保存Cookie</div><div>&nbsp;- 之后浏览器的每次请求都会将Cookie发给服务器端。</div><div><br></div><div>服务器响应的Cookie值在Set-Cookie中，最后将Set-Cookie设置在响应报文头部中返回，格式与请求中的格式不太一样，请求的cookie为对象：</div><div>```javascript</div><div>Set-Cookie: name=value; Path=/; Expires=Sun, 23-Apr-23 09:01:35 GMT; Domain=.domain.com;</div><div>```</div><div><br></div><div>服务端：</div><div>```javascript</div><div>var http = require('http');</div><div><br></div><div>http.createServer(function (req, res) {</div><div><span style=\"white-space:pre\">\t</span>req.cookies = parseCookie(req.headers.cookie);<span style=\"white-space:pre\">\t</span>//解析客户端的cookie，,暂存在req.cookies上</div><div><span style=\"white-space:pre\">\t</span>handle(req, res); //进一步业务处理</div><div>}).listen(8888);</div><div><br></div><div>//解析客户端传来的cookie</div><div>var parseCookie = function(cookie) {</div><div><span style=\"white-space:pre\">\t</span>var cookies = {};</div><div><span style=\"white-space:pre\">\t</span>if(!cookie) { //为空，返回cookies</div><div><span style=\"white-space:pre\">\t\t</span>return cookies;</div><div><span style=\"white-space:pre\">\t</span>}</div><div><span style=\"white-space:pre\">\t</span>//存在cookie，则解析客户端的cookie，存储于cookies给服务端使用</div><div><span style=\"white-space:pre\">\t</span>var list = cookie.split(';'); //将Cookie值：key1=value; key2=value2转变为数组的形式</div><div><span style=\"white-space:pre\">\t</span>for(var i = 0; i &lt; list.length; i++) {&nbsp;&nbsp;</div><div><span style=\"white-space:pre\">\t\t</span>var pair = list[i].split('=');</div><div><span style=\"white-space:pre\">\t\t</span>cookies[pair[0].trim()] = pair[1].trim(); //trim用于删除字符串头尾的空格</div><div><span style=\"white-space:pre\">\t</span>}</div><div><span style=\"white-space:pre\">\t</span>return cookies; //以数组形式返回</div><div>}</div><div><br></div><div>//业务处理</div><div>var handle = function(req, res) {</div><div><span style=\"white-space:pre\">\t</span>if(!req.cookies.isVisit) {</div><div><span style=\"white-space:pre\">\t\t</span>res.setHeader('Set-Cookie', serialize('isVisit', '1'));&nbsp; //设置</div><div><span style=\"white-space:pre\">\t\t</span>res.writeHead(200, {\"Content-Type\": \"text/html;charset=utf-8\"});</div><div><span style=\"white-space:pre\">\t\t</span>res.write('&lt;h1&gt;第一次登陆&lt;/h1&gt;');</div><div><span style=\"white-space:pre\">\t\t</span>res.end();</div><div><span style=\"white-space:pre\">\t</span>}</div><div><span style=\"white-space:pre\">\t</span>else {</div><div><span style=\"white-space:pre\">\t\t</span>res.writeHead(200, {\"Content-Type\": \"text/html;charset=utf-8\"});</div><div><span style=\"white-space:pre\">\t\t</span>res.write('&lt;h1&gt;欢迎再次登陆&lt;/h1&gt;');</div><div><span style=\"white-space:pre\">\t\t</span>res.end();</div><div><span style=\"white-space:pre\">\t</span>}</div><div>}</div><div><br></div><div>//格式化将返回的cookie</div><div>var serialize = function (name, val, opt) {</div><div><span style=\"white-space:pre\">\t</span>var pairs = [name + '=' + encodeURIComponent(val)];</div><div><span style=\"white-space:pre\">\t</span>opt = opt || {};</div><div><br></div><div><span style=\"white-space:pre\">\t</span>if(opt.path) pair.push('Path=' + opt.path);<span style=\"white-space:pre\">\t</span>//还可以设置其他选项Domain、Expires等</div><div><span style=\"white-space:pre\">\t</span>return pairs.join(';');&nbsp; //将数组拼接成用分号连接的字符串</div><div>}</div><div>```</div><div>通过console.log(res); 会发现此时的服务器端响应报头加上了Set-Cookie。而之后没通过setHeader设置的Set-Cookie响应报头，是不会再出现Set-Cookie的，为null。</div><div><span class=\"img-wrapper\"></span><span class=\"img-wrapper\"><img src=\"http://119.45.55.131:3000/upload/ldDq3ckvWYljlatB9p1vxN0M.png\"><span>![在这里插入图片描述](http://119.45.55.131:3000/upload/ldDq3ckvWYljlatB9p1vxN0M.png)</span></span><br></div><div><span class=\"img-wrapper\"><span class=\"img-wrapper\"><img src=\"http://119.45.55.131:3000/upload/nofmUXLoF-SY-Uq9jJ6jEgEX.png\"><span>![在这里插入图片描述](http://119.45.55.131:3000/upload/nofmUXLoF-SY-Uq9jJ6jEgEX.png)</span></span><br></span></div><div>客户端通过控制台输入，document.cookie查看：<br><span class=\"img-wrapper\"><span class=\"img-wrapper\"><img src=\"http://119.45.55.131:3000/upload/mOiRqzw_opzWzQbGgW3G0Hew.png\"><span>![在这里插入图片描述](http://119.45.55.131:3000/upload/mOiRqzw_opzWzQbGgW3G0Hew.png)</span></span><br></span></div><div>客户端收到带Set-Cookie的响应后，在之后的请求时会在Cookie字段中带上这个值。</div><div><span class=\"img-wrapper\"><span class=\"img-wrapper\"><img src=\"http://119.45.55.131:3000/upload/RSMCKJTCthnYDdhyDGjaVRx-.png\"><span>![在这里插入图片描述](http://119.45.55.131:3000/upload/RSMCKJTCthnYDdhyDGjaVRx-.png)</span></span><br></span></div><div><div>Set-Cookie在报头中可能存在多个字段。因此res.setHeader的第二个参数可以是一个数组：</div><div><br></div><div>```javascript</div><div>res.setHeader('Set-Cookie', [serialize('foo', 'bar'), serialize('baz', 'val')]);</div><div>```</div><div>最后生成两条Set-Cookie字段：</div><div><br></div><div>```javascript</div><div>Set-Cookie: foo=bar; Path=/; Expires=Sun, 23-Apr-23 09:01:35 GMT; Domain=.domain.com;&nbsp;</div><div>Set-Cookie: baz=val; Path=/; Expires=Sun, 23-Apr-23 09:01:35 GMT; Domain=.domain.com;</div><div>```</div><div><br></div><div>&gt;《深入浅出Node.js》<br></div><div><br></div><br><br></div>",
      "article_time": "2024-7-7 13:43:24",
      "categories_id": "12",
      "tags": "node,cookie"
    },
    {
      "article_id": "224",
      "article_title": "babel-loader配置 @beta版",
      "article_content": "<div>## 作用</div><div>使用ES6编写js语法时，由于有些浏览器不支持，故需使用babel插件将ES6转换为ES5。</div><div><br></div><div>## 安装</div><div>webpack 3.x | babel-loader 8.x | babel 7.x</div><div>```javascript</div><div>npm install babel-loader@8.0.0-beta.0 @babel/core @babel/preset-env webpack --save-dev</div><div>```</div><div>webpack 3.x babel-loader 7.x | babel 6.x</div><div>```javascript</div><div>npm install babel-loader babel-core babel-preset-env webpack --save-dev</div><div>```</div><div>我这里用第一种。</div><div><br></div><div>## 配置</div><div>webpack.config.js</div><div>```javascript</div><div>{</div><div><span style=\"white-space:pre\">\t</span>test: /\\.js$/,</div><div><span style=\"white-space:pre\">\t</span>loader: ['babel-loader'],</div><div><span style=\"white-space:pre\">\t</span>exclude: /node_modules/</div><div>}</div><div>```</div><div><br></div><div>新建.babelrc文件，并写入babel的配置，webpack会依赖此配置文件来使用babel编译ES6代码</div><div><br></div><div>```javascript</div><div>{</div><div><span style=\"white-space:pre\">\t</span>\"presets\": [\"@babel/preset-env\"]</div><div>}</div><div>```</div><div>或者不使用.babelrc文件，直接加在webpack.config.js</div><div><br></div><div>```javascript</div><div>module: {\n  rules: [\n    {\n      test: /\\.js$/,\n      exclude: /(node_modules|bower_components)/,\n      use: {\n        loader: 'babel-loader',\n        options: {\n          presets: ['@babel/preset-env']\n        }\n      }\n    }\n  ]\n}<br></div><div>```</div><div>添加配置</div><div>1、babel会在每个文件都插入辅助代码，使得体积过大，可以引入 babel runtime 作为一个独立模块，来避免重复引入。</div><div>```javascript</div><div>npm install @babel/plugin-transform-runtime --save-dev</div><div>npm install @babel/runtime --save</div><div>```</div><div>2、'modules':false：设置模块引用规则，可以设置成\"amd\" | \"umd\" | \"systemjs\" | \"commonjs\" | false, defaults to \"commonjs\",设置了false，就是用es6以上默认的规则。</div><div><br></div><div>3、targets.browsers:设置兼容的浏览器范围</div><div><br></div><div>4、\"comments\": false 删除已编译代码的注释</div><div><br></div><div>.babelrc完整版</div><div><br></div><div>```javascript</div><div>{\n  \"presets\": [\n    [\"@babel/preset-env\", {\n      \"modules\": false,\n      \"targets\": {\n        \"browsers\": [\"&gt; 1%\", \"last 2 versions\", \"not ie &lt;= 8\"]\n      }\n    }]\n  ],\n  \"plugins\": [\"@babel/transform-runtime\"]，\n  \"comments\": false\n}<br></div><div>```</div><div><br></div><div><br></div><div>&gt; https://www.jianshu.com/p/0dc3bddb6da8?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=seo_notes&amp;utm_source=recommendation</div><div>&gt; https://babeljs.io/docs/en/babel-preset-stage-2/</div><div>&gt; https://www.webpackjs.com/loaders/babel-loader/</div><div><br></div>",
      "article_time": "2024-7-7 13:44:13",
      "categories_id": "13",
      "tags": "babel-loader"
    },
    {
      "article_id": "226",
      "article_title": "浏览器窗口缩小后,滚动条拉至右边显示空白",
      "article_content": "<div><div>**问题描述:**</div><div>当浏览器缩小后,出现滚动条,拉至右边,显示出来的部分为空白．</div><div><br></div><div>**原因：**</div><div>通过控制台的查看，可得知，由于固定了子元素的宽度，当浏览器窗口缩小后，将导致子元素宽度大于父元素的宽度，子元素将父元素撑开所致，如图：</div></div><div><span class=\"img-wrapper\"></span><span class=\"img-wrapper\"><img src=\"http://119.45.55.131:3000/upload/ZsKJsDbLTq7gxEA8mrCt3hyf.png\"><span>![在这里插入图片描述](http://119.45.55.131:3000/upload/ZsKJsDbLTq7gxEA8mrCt3hyf.png)</span></span><br></div><div><div>**解决方案：**</div><div>第一种：在父元素上添加样式:</div><div>```javascript</div><div>style=\"width:expression(document.body.clientWidth &lt;= 1200? '1200px': 'auto');min-width:1200px\"</div><div>```</div><div>由于IE6不支持min、max,为了兼容,故使用width:expression[^1](document.body.clientWidth &lt;= 1200? '1200px': 'auto');</div><div>expression将CSS属性和Javascript脚本关联起来，是动态设置CSS属性的强大方法。但expression对浏览器的资源要求高（因为它的计算频率高）。在性能优化方面，可以将第一次计算出的结果赋值给指定的样式属性，并用这个属性代替expression。但仍存在很多问题，所以尽量不使用。<br></div><div><br></div><div>第二种：修改子元素样式的固定宽度,将width: 1170px;改为max-width: 1170px;</div><div><br></div><div>第三种：相应式布局，随着浏览器宽度的变化，调整子元素宽度和布局，避免撑开父元素宽度的情况出现。</div><div><br></div><div><br></div></div><div><br></div>",
      "article_time": "2024-7-7 15:14:50",
      "categories_id": "11",
      "tags": ""
    },
    {
      "article_id": "228",
      "article_title": "最简单的SVG图标使用方式",
      "article_content": "<div>## 简介</div><div>**Icon Sprite** ：CSS精灵或雪碧图，是一种网页图片应用处理方式。原理是，把网页中一些Icon整合到一张图片文件中。再通过一定方式从图片文件中取出所需Icon并显示。其中CSS Sprite、Icon Font使用最多。</div><div><br></div><div>**CSS Sprite**：</div><div>原理是将多个icon按一定规律整合到图片文件中，再利用CSS的\"background-image\"，\"background-repeat\"，\"background-position\"的组合进行图片定位并显示。优点：技术成熟，兼容性好；缺点：在实际需求中需为保存不用颜色、大小的Icon，最终难以管理。</div><div><br></div><div>**Icon Font**：</div><div>原理是将Icon定义为图片字体，在CSS中用@font-face引入Icon Font自定义字体, 再利用font-family和字符码显示出指定的图标。优点：维护比图片方便；缺点：只有单色，字体生成比CSS Sprite更复杂。</div><div> </div><div>## SVG Sprite介绍</div><div> SVG即可缩放矢量图形 (Scalable Vector Graphics)的简称, 是一种用来描述二维矢量图形的XML标记语言. SVG图形不依赖于分辨率, 因此图形不会因为放大而显示出明显的锯齿边缘。</div><div>&nbsp;</div><div>**优点**</div><div>相比CSS Sprite和Icon Font有着明显的优势，CSS Sprite技术成熟兼容性好，</div><div><br></div><div>&nbsp;- 放大缩小不会失真（不依赖于分辨率，放大显示出明显得锯齿边缘）</div><div>&nbsp;- 大小颜色等属性自定义灵活</div><div>&nbsp;- 体积小同时管理方便</div><div>&nbsp;</div><div>**缺点**</div><div>&nbsp;虽然灵活度高，但SVG兼容性有待考究，其渲染性能也不及图片和字体那么高，可能在某些情况下不适用。但在一般的场景中，svg sprite 还能够给开发带来很大的便利。</div><div>## 使用</div><div>1、在阿里巴巴的图标库(https://www.iconfont.cn/)选择图标后 -&gt; 点击下载SVG -&gt;（选择颜色、大小后）点击复制SVG。</div><div><span class=\"img-wrapper\"><img src=\"http://119.45.55.131:3000/upload/yg_68YrNG67zaONrRHBOQuUc.png\"><span>![在这里插入图片描述](http://119.45.55.131:3000/upload/yg_68YrNG67zaONrRHBOQuUc.png)</span></span><br></div><div>2、粘贴在html中。也可在粘贴的代码中修改Icon大小和颜色。<br></div><div><span class=\"img-wrapper\"></span><span class=\"img-wrapper\"><img src=\"http://119.45.55.131:3000/upload/HiakhIu-OMWsE2Uwy1Mcsk9i.png\"><span>![在这里插入图片描述](http://119.45.55.131:3000/upload/HiakhIu-OMWsE2Uwy1Mcsk9i.png)</span></span></div><div><span class=\"img-wrapper\"><span class=\"img-wrapper\"><img src=\"http://119.45.55.131:3000/upload/BvfOqfjuqftWP_SSvjE2UTjb.png\"><span>![在这里插入图片描述](http://119.45.55.131:3000/upload/BvfOqfjuqftWP_SSvjE2UTjb.png)</span></span><br></span></div><div><div>&gt;进一步深入了解和使用，参考文章：&nbsp;</div><div>&gt; https://www.jianshu.com/p/5723a9dacd92</div><div>&gt; https://www.runoob.com/svg/svg-tutorial.html</div><br></div>",
      "article_time": "2024-7-7 15:20:08",
      "categories_id": "15",
      "tags": "svg sprite,雪碧图"
    },
    {
      "article_id": "229",
      "article_title": "Node.js简单使用session，帮助理解实现原理",
      "article_content": "<div>## 一、session使用</div><div>Cookie可以实现浏览器和服务器状态的记录，但Cookie会出现存储体积过大和可以在前后端修改的问题。</div><div>为了解决Cookie的数据敏感问题，Session应运而生。常见的实现方式是基于Cookie。只将口令放置Cookie，通过口令实现前后端数据的映射，大部分数据存储于服务器的session中，这里会有一个全局sessions去存储每个用户的session，并设置每个的有效期，一般20分钟。超时则重新生成和更新全局sessions。</div><div><br></div><div>以下代码为，在有效期内，判断用户是否第一次登陆。</div><div>服务器端：</div><div>```</div><div>var http = require('http');</div><div><br></div><div>//全局sessions存放所有的session</div><div>var sessions = {};</div><div>var key = 'session_id';</div><div>var EXPIRES = 20 * 60 * 1000;<span style=\"white-space:pre\">\t</span>//过期时长</div><div><br></div><div>http.createServer(function (req, res) {</div><div><span style=\"white-space:pre\">\t</span>req.cookies = parseCookie(req.headers.cookie);<span style=\"white-space:pre\">\t</span>//解析客户端的cookie，,暂存在req.cookies上</div><div><span style=\"white-space:pre\">\t</span>var id = req.cookies[key];  //取出每个用户唯一的id口令</div><div><span style=\"white-space:pre\">\t</span>//更新session状态</div><div><span style=\"white-space:pre\">\t</span>if (!id) {</div><div><span style=\"white-space:pre\">\t\t</span>req.session = generate();  //生成新的session</div><div><span style=\"white-space:pre\">\t</span>}</div><div><span style=\"white-space:pre\">\t</span>else {</div><div><span style=\"white-space:pre\">\t\t</span>var session = sessions[id]; //从全局sessions中取出对应id的session，判断session状态</div><div><span style=\"white-space:pre\">\t\t</span>if (session) {</div><div><span style=\"white-space:pre\">\t\t\t</span>if (session.cookie.expire &gt; (new Date()).getTime()) {</div><div><span style=\"white-space:pre\">\t\t\t\t</span>//更新超时时间</div><div><span style=\"white-space:pre\">\t\t\t\t</span>session.cookie.expire = (new Date()).getTime() + EXPIRES;</div><div><span style=\"white-space:pre\">\t\t\t\t</span>req.session = session;</div><div><span style=\"white-space:pre\">\t\t\t</span>}</div><div><span style=\"white-space:pre\">\t\t\t</span>else {</div><div><span style=\"white-space:pre\">\t\t\t\t</span>//超时了，删除旧的数据，重新生成</div><div><span style=\"white-space:pre\">\t\t\t\t</span>delete sessions[id];</div><div><span style=\"white-space:pre\">\t\t\t\t</span>req.session = generate();</div><div><span style=\"white-space:pre\">\t\t\t</span>}</div><div><span style=\"white-space:pre\">\t\t</span>}</div><div><span style=\"white-space:pre\">\t\t</span>else {</div><div><span style=\"white-space:pre\">\t\t\t</span>//sessions中不存在该id的session（id口令匹配错误或客户端保存着id，但服务器端因超时导致session已取消）,重新生成</div><div><span style=\"white-space:pre\">\t\t\t</span>req.session = generate();</div><div><span style=\"white-space:pre\">\t\t</span>}</div><div><span style=\"white-space:pre\">\t</span>}</div><div><br></div><div><span style=\"white-space:pre\">\t</span>//业务处理，返回客户端</div><div><span style=\"white-space:pre\">\t</span>handle(req, res);</div><div><br></div><div>}).listen(8888);</div><div><br></div><div><br></div><div>//生成新的session,并存储于sessions</div><div>var generate = function() {</div><div><span style=\"white-space:pre\">\t</span>var session = {};</div><div><span style=\"white-space:pre\">\t</span>session.id = (new Date()).getTime() + Math.random();&nbsp; //id为当前时间加上随机值</div><div><span style=\"white-space:pre\">\t</span>session.cookie = {</div><div><span style=\"white-space:pre\">\t\t</span>expire: (new Date()).getTime() + EXPIRES //cookie为当前时间加上超时时长</div><div><span style=\"white-space:pre\">\t</span>};</div><div><span style=\"white-space:pre\">\t</span>sessions[session.id] = session;</div><div><span style=\"white-space:pre\">\t</span>return session;&nbsp; //返回当前新建的session</div><div>};</div><div><br></div><div>//业务处理</div><div>var handle = function (req,res) {</div><div><span style=\"white-space:pre\">\t</span>if (!req.session.isVisit) {</div><div><span style=\"white-space:pre\">\t\t</span>sessions[req.session.id].isVisit = true;<span style=\"white-space:pre\">\t</span>//修改服务器相应的session状态</div><div><span style=\"white-space:pre\">\t\t</span>res.setHeader('Set-Cookie', serialize(key, req.session.id));&nbsp; //头部写入session的id</div><div><span style=\"white-space:pre\">\t\t</span>res.writeHead(200, {\"Content-Type\":\"text/html;charset=utf-8\"});</div><div><span style=\"white-space:pre\">\t\t</span>res.end(\"&lt;h1&gt;第一次登陆&lt;/h1&gt;\");</div><div><span style=\"white-space:pre\">\t</span>}</div><div><span style=\"white-space:pre\">\t</span>else {</div><div><span style=\"white-space:pre\">\t\t</span>res.writeHead(200, {\"Content-Type\":\"text/html;charset=utf-8\"});</div><div><span style=\"white-space:pre\">\t\t</span>res.end('&lt;h1&gt;再次登陆&lt;/h1&gt;');</div><div><span style=\"white-space:pre\">\t</span>}</div><div>}</div><div><br></div><div>//解析客户端传来的cookie</div><div>var parseCookie = function(cookie) {</div><div><span style=\"white-space:pre\">\t</span>var cookies = {};</div><div><span style=\"white-space:pre\">\t</span>if(!cookie) { //为空，返回cookies</div><div><span style=\"white-space:pre\">\t\t</span>return cookies;</div><div><span style=\"white-space:pre\">\t</span>}</div><div><span style=\"white-space:pre\">\t</span>//存在cookie，则解析客户端的cookie，存储于cookies给服务端使用</div><div><span style=\"white-space:pre\">\t</span>var list = cookie.split(';'); //将Cookie值：key1=value; key2=value2转变为数组的形式</div><div><span style=\"white-space:pre\">\t</span>for(var i = 0; i &lt; list.length; i++) {&nbsp;&nbsp;</div><div><span style=\"white-space:pre\">\t\t</span>var pair = list[i].split('=');</div><div><span style=\"white-space:pre\">\t\t</span>cookies[pair[0].trim()] = pair[1].trim();//trim用于删除字符串头尾的空格</div><div><span style=\"white-space:pre\">\t</span>}</div><div><span style=\"white-space:pre\">\t</span>return cookies;</div><div>}</div><div><br></div><div>//格式化cookie</div><div>var serialize = function (name, val, opt) {</div><div><span style=\"white-space:pre\">\t</span>var pairs = [name + '=' + encodeURIComponent(val)];</div><div><span style=\"white-space:pre\">\t</span>opt = opt || {};</div><div><br></div><div><span style=\"white-space:pre\">\t</span>if(opt.path) pair.push('Path=' + opt.path);<span style=\"white-space:pre\">\t</span>//还可以设置其他选项Domain、Expires等</div><div><span style=\"white-space:pre\">\t</span>if (opt.maxAge) pairs.push('Max-Age=' + opt.maxAge); //告诉浏览器多久后过期</div><div><span style=\"white-space:pre\">\t</span>return pairs.join(';');&nbsp; //将数组拼接成用分号连接的字符串</div><div>}</div><div>```</div><div>服务器端查看：</div><div><span class=\"img-wrapper\"><img src=\"http://119.45.55.131:3000/upload/CgXiLoTYDeJJ_BB2NpubBzPu.png\"><span>![在这里插入图片描述](http://119.45.55.131:3000/upload/CgXiLoTYDeJJ_BB2NpubBzPu.png)</span></span><br></div><div>客户端查看：</div><div><span class=\"img-wrapper\"><img src=\"http://119.45.55.131:3000/upload/j7aG2ghKtzMvJlbk8gcqhJAU.png\"><span>![在这里插入图片描述](http://119.45.55.131:3000/upload/j7aG2ghKtzMvJlbk8gcqhJAU.png)</span></span><br></div><div><div>当关闭浏览器时，cookie便会消失，可通过maxAge去设置永久时长：<br></div><div><br></div><div>```</div><div>var opt = {};</div><div>opt.maxAge = 12000;<span style=\"white-space:pre\">\t</span>//设置永久过期时间</div><div>res.setHeader('Set-Cookie', serialize(key, req.session.id, opt));</div><div>```</div><div><br></div><div>## 二、session安全性</div><div>由于Session的口令保存在客户端，会存在口令被盗用的情况。一种做法是将口令通过私钥加密进行签名。会用到crypto模块。</div><div>访问过程为：</div><div>&nbsp;- 服务器将加密的口令发送给客户端</div><div>&nbsp;- 客户端保存口令</div><div>&nbsp;- 客户端每次访问服务器，带着加密口令</div><div>&nbsp;- 服务器解析口令，进行业务处理</div><div><br></div><div>```</div><div>var crypto = require('crypto');</div><div><br></div><div>//加密函数</div><div>var sign = function (val, secret) {</div><div><span style=\"white-space:pre\">\t</span>return val + '.' + crypto</div><div><span style=\"white-space:pre\">\t\t</span>.createHmac('sha256', secret)&nbsp; //使用给定的sha256哈希函数算法和密钥,返回一个Hmac对象</div><div><span style=\"white-space:pre\">\t\t</span>.update(val+'')&nbsp; //传入需要加密的数据,转换为字符串,更新Hamc</div><div><span style=\"white-space:pre\">\t\t</span>.digest('base64') //base64编码后,返回摘要</div><div>&nbsp;<span style=\"white-space:pre\">\t\t</span>.replace(/\\=+$/, ''); //将字符串的多个=为结尾部分替换为''</div><div>}</div><div>//解密函数</div><div>var unsign = function(val, secret) {</div><div><span style=\"white-space:pre\">\t</span>var str = (val || '').slice(0, (val || '').lastIndexOf('.'));&nbsp; //取得加密前的口令</div><div><span style=\"white-space:pre\">\t</span>return sign(str, secret) == val ? str: false;<span style=\"white-space:pre\">\t</span>//将取得的口令与服务端的签名加密，比较是否与客户端发来的加密口令匹配</div><div>}</div><div>```</div><div>使用如下：</div><div><span class=\"img-wrapper\"><img src=\"http://119.45.55.131:3000/upload/boKmSowZvPGEB-mrc023krbl.png\"><span>![在这里插入图片描述](http://119.45.55.131:3000/upload/boKmSowZvPGEB-mrc023krbl.png)</span></span><br></div><div>在响应头部插入加密口令。</div><div><span class=\"img-wrapper\"><img src=\"http://119.45.55.131:3000/upload/yt99gNu7GiZ2EBN1AQ_rCqXv.png\"><span>![在这里插入图片描述](http://119.45.55.131:3000/upload/yt99gNu7GiZ2EBN1AQ_rCqXv.png)</span></span><br></div><div><div>对收到的请求报文的口令进行解密。</div><div><br></div><div>客户端：</div></div><div><br></div><br></div><div><div>&gt; 《深入浅出Node.js》</div><div>&gt; http://nodejs.cn/api/crypto.html</div></div>",
      "article_time": "2024-7-7 15:27:51",
      "categories_id": "12",
      "tags": "session"
    },
    {
      "article_id": "230",
      "article_title": "test",
      "article_content": "test",
      "article_time": "2024-7-7 15:28:22",
      "categories_id": "0",
      "tags": ""
    },
    {
      "article_id": "231",
      "article_title": "box",
      "article_content": "box",
      "article_time": "2024-7-7 15:28:37",
      "categories_id": "0",
      "tags": ""
    },
    {
      "article_id": "245",
      "article_title": "测试",
      "article_content": "册数哈哈哈哈",
      "article_time": "2024-7-7 17:38:57",
      "categories_id": "16",
      "tags": ""
    },
    {
      "article_id": "246",
      "article_title": "测试",
      "article_content": "cdscscsdcsdcdcsc",
      "article_time": "2024-7-7 18:29:16",
      "categories_id": "15",
      "tags": ""
    },
    {
      "article_id": "247",
      "article_title": "测试博客",
      "article_content": "测试博客",
      "article_time": "2024-7-10 21:35:08",
      "categories_id": "16",
      "tags": ""
    },
    {
      "article_id": "248",
      "article_title": "测试博客博客",
      "article_content": "测试博客博客",
      "article_time": "2024-7-10 21:41:12",
      "categories_id": "16",
      "tags": ""
    }
  ]
}